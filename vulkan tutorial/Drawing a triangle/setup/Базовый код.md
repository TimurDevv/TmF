## Общая структура

В предыдущей главе вы создали проект Vulkan со всей правильной конфигурацией и протестировали его с помощью примера кода. В этой главе мы начинаем с нуля со следующего кода:

```cpp
#include <vulkan/vulkan.h>
#include <iostream>
#include <stdexcept>
#include <cstdlib>
  
class HelloTriangleApplication {
public:
    void run() {
        initVulkan();
        mainLoop();
        cleanup();
    }
private:
    void initVulkan() {
   }
      void mainLoop() {
     }
      void cleanup() {
    }
};
int main() {
    HelloTriangleApplication app;
    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
```
Сначала мы включаем заголовок Vulkan из LunarG SDK, который предоставляет функции, структуры и перечисления. Заголовки `stdexcept`и `iostream`включены для сообщения и распространения ошибок. Заголовок `cstdlib` содержит макросы `EXIT_SUCCESS`и .`EXIT_FAILURE`

Сама программа заключена в класс, в котором мы будем хранить объекты Vulkan как частные члены класса и добавлять функции для инициации каждого из них, которые будут вызываться из `initVulkan`функции. После того, как все подготовлено, мы входим в основной цикл, чтобы начать рендеринг кадров. Мы заполним `mainLoop` функцию, чтобы включить цикл, который повторяется до тех пор, пока окно не закроется через мгновение. Как только окно закроется и `mainLoop`вернется, мы обязательно освободим ресурсы, которые мы использовали в `cleanup`функции.

Если во время выполнения произойдет какая-либо фатальная ошибка, мы создадим `std::runtime_error`исключение с описательным сообщением, которое будет передано обратно в `main`функцию и напечатано в командной строке. Чтобы обрабатывать различные стандартные типы исключений, мы перехватываем более общий `std::exception`. Одним из примеров ошибки, с которой мы вскоре разберемся, является обнаружение того, что определенное требуемое расширение не поддерживается.

Примерно в каждой главе, следующей за этой, будет добавлена ​​одна новая функция, которая будет вызываться из, `initVulkan`и один или несколько новых объектов Vulkan для закрытых членов класса, которые необходимо освободить в конце в `cleanup`.
## Интеграция GLFW

Vulkan отлично работает без создания окна, если вы хотите использовать его для рендеринга вне экрана, но гораздо интереснее показать что-то на самом деле! Сначала замените `#include <vulkan/vulkan.h>`строку на
```cpp
#define GLFW_INCLUDE_VULKAN 
#include <GLFW/glfw3.h>
```
Таким образом, GLFW будет включать свои собственные определения и автоматически загружать с ними заголовок Vulkan. Добавьте `initWindow`функцию и добавьте к ней вызов из `run` функции перед другими вызовами. Мы будем использовать эту функцию для инициализации GLFW и создания окна.
```cpp
void run() {
    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}
private:
    void initWindow() {
    }
```
Самый первый вызов `initWindow`должен быть `glfwInit()`, который инициализирует библиотеку GLFW. Поскольку GLFW изначально был разработан для создания контекста OpenGL, нам нужно указать ему не создавать контекст OpenGL с помощью последующего вызова:
```
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
```
Поскольку обработка окон с измененным размером требует особой осторожности, которую мы рассмотрим позже, отключите ее сейчас с помощью другого вызова подсказки окна:
```
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
```
Все, что осталось сейчас, это создать фактическое окно. Добавьте `GLFWwindow* window;` закрытый член класса, чтобы сохранить ссылку на него, и инициализируйте окно с помощью:
```cpp
 window = glfwCreateWindow(800, 600, "Vulkan", nullptr, nullptr);
```
Первые три параметра определяют ширину, высоту и заголовок окна. Четвертый параметр позволяет дополнительно указать монитор, на котором будет открываться окно, а последний параметр имеет отношение только к OpenGL.

Рекомендуется использовать константы вместо жестко заданных значений ширины и высоты, потому что в будущем мы будем обращаться к этим значениям пару раз. Я добавил следующие строки над `HelloTriangleApplication`определением класса:
```cpp
const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;
```
и заменил вызов создания окна на
```cpp
window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
```
Теперь у вас должна быть `initWindow` функция, которая выглядит следующим образом:
```cpp
void initWindow() { 
glfwInit();
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr); 
}
```
Чтобы приложение продолжало работать до тех пор, пока не произойдет ошибка или окно не будет закрыто, нам нужно добавить цикл обработки событий в `mainLoop`функцию следующим образом:
```cpp
void mainLoop() {
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }
}
```
Этот код должен быть достаточно понятным. Он зацикливается и проверяет события, такие как нажатие кнопки X, до тех пор, пока окно не будет закрыто пользователем. Это также цикл, в котором мы позже вызовем функцию для рендеринга одного кадра.

Как только окно закроется, нам нужно очистить ресурсы, уничтожив его и завершив сам GLFW. Это будет наш первый `cleanup`код:
```cpp
void cleanup() { glfwDestroyWindow(window); glfwTerminate(); }
```
Когда вы запустите программу сейчас, вы должны увидеть окно под названием `Vulkan`show до тех пор, пока приложение не будет завершено, закрыв окно. Теперь, когда у нас есть скелет приложения Vulkan, давайте [создадим первый объект Vulkan](https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance) !
[код С++](https://vulkan-tutorial.com/code/00_base_code.cpp)